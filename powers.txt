CREATE TABLE powers (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  activation_chance INTEGER NOT NULL,
  icon VARCHAR(10) DEFAULT '⚡',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Inserir os poderes
INSERT INTO powers (name, description, activation_chance, icon) VALUES
('Faca Rápida', 'Golpeia duas vezes rapidamente com 60% do dano base.', 20, '⚡'),
('Ataque Perfuro-Cortante', 'Ignora defesa do inimigo.', 15, '🗡️'),
('Frenesi', 'Duplica velocidade de ataque por 3 segundos.', 15, '💨'),
('Fúria', 'Garante +30% de chance de crítico nos próximos 2 ataques. Perde 10% do HP máximo ao ativar.', 25, '🔥'),
('Berserker', 'Sempre que o HP estiver abaixo de 30%, o dano aumenta +20%.', 100, '😤'),
('Reflexão Total', 'Devolve 100% do dano recebido ao atacante.', 10, '🛡️'),
('Guardião Imortal', 'Ao receber um golpe fatal, resiste com 1 de HP. Só pode ativar uma vez por combate.', 100, '💀');

-- Tabela de poderes do usuário
CREATE TABLE user_powers (
  id SERIAL PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  power_id INTEGER REFERENCES powers(id) ON DELETE CASCADE,
  slot_position INTEGER CHECK (slot_position >= 1 AND slot_position <= 3),
  acquired_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, power_id),
  UNIQUE(user_id, slot_position)
);

-- Função para obter poderes do usuário
CREATE OR REPLACE FUNCTION get_user_powers(user_id_param UUID)
RETURNS TABLE (
  slot_1_power_id INTEGER,
  slot_1_power_name VARCHAR,
  slot_1_power_description TEXT,
  slot_1_power_icon VARCHAR,
  slot_1_activation_chance INTEGER,
  slot_2_power_id INTEGER,
  slot_2_power_name VARCHAR,
  slot_2_power_description TEXT,
  slot_2_power_icon VARCHAR,
  slot_2_activation_chance INTEGER,
  slot_3_power_id INTEGER,
  slot_3_power_name VARCHAR,
  slot_3_power_description TEXT,
  slot_3_power_icon VARCHAR,
  slot_3_activation_chance INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    MAX(CASE WHEN up.slot_position = 1 THEN p.id END) as slot_1_power_id,
    MAX(CASE WHEN up.slot_position = 1 THEN p.name END) as slot_1_power_name,
    MAX(CASE WHEN up.slot_position = 1 THEN p.description END) as slot_1_power_description,
    MAX(CASE WHEN up.slot_position = 1 THEN p.icon END) as slot_1_power_icon,
    MAX(CASE WHEN up.slot_position = 1 THEN p.activation_chance END) as slot_1_activation_chance,
    MAX(CASE WHEN up.slot_position = 2 THEN p.id END) as slot_2_power_id,
    MAX(CASE WHEN up.slot_position = 2 THEN p.name END) as slot_2_power_name,
    MAX(CASE WHEN up.slot_position = 2 THEN p.description END) as slot_2_power_description,
    MAX(CASE WHEN up.slot_position = 2 THEN p.icon END) as slot_2_power_icon,
    MAX(CASE WHEN up.slot_position = 2 THEN p.activation_chance END) as slot_2_activation_chance,
    MAX(CASE WHEN up.slot_position = 3 THEN p.id END) as slot_3_power_id,
    MAX(CASE WHEN up.slot_position = 3 THEN p.name END) as slot_3_power_name,
    MAX(CASE WHEN up.slot_position = 3 THEN p.description END) as slot_3_power_description,
    MAX(CASE WHEN up.slot_position = 3 THEN p.icon END) as slot_3_power_icon,
    MAX(CASE WHEN up.slot_position = 3 THEN p.activation_chance END) as slot_3_activation_chance
  FROM user_powers up
  JOIN powers p ON up.power_id = p.id
  WHERE up.user_id = user_id_param;
END;
$$ LANGUAGE plpgsql;

-- Políticas RLS
ALTER TABLE powers ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_powers ENABLE ROW LEVEL SECURITY;

-- Todos podem ver os poderes
CREATE POLICY "Anyone can view powers" ON powers FOR SELECT USING (true);

-- Usuários podem ver apenas seus próprios poderes
CREATE POLICY "Users can view own powers" ON user_powers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own powers" ON user_powers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own powers" ON user_powers FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own powers" ON user_powers FOR DELETE USING (auth.uid() = user_id);

================================

DROP TABLE IF EXISTS user_powers;

CREATE TABLE user_powers (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  -- Poderes possuídos (array de IDs)
  owned_powers INTEGER[] DEFAULT '{}',
  -- Poderes equipados nos slots
  equipped_power_1 INTEGER REFERENCES powers(id),
  equipped_power_2 INTEGER REFERENCES powers(id),
  equipped_power_3 INTEGER REFERENCES powers(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Função para adicionar um poder ao usuário
CREATE OR REPLACE FUNCTION add_power_to_user(user_id_param UUID, power_id_param INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
  user_exists BOOLEAN;
BEGIN
  -- Verificar se o usuário já tem registro
  SELECT EXISTS(SELECT 1 FROM user_powers WHERE user_id = user_id_param) INTO user_exists;
  
  IF NOT user_exists THEN
    -- Criar registro do usuário
    INSERT INTO user_powers (user_id, owned_powers) 
    VALUES (user_id_param, ARRAY[power_id_param]);
  ELSE
    -- Adicionar poder ao array se não existir
    UPDATE user_powers 
    SET owned_powers = array_append(owned_powers, power_id_param),
        updated_at = NOW()
    WHERE user_id = user_id_param 
    AND NOT (power_id_param = ANY(owned_powers));
  END IF;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Função para equipar poder em slot específico
CREATE OR REPLACE FUNCTION equip_power(user_id_param UUID, power_id_param INTEGER, slot_param INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
  slot_column TEXT;
  has_power BOOLEAN;
BEGIN
  -- Verificar se o usuário possui o poder
  SELECT power_id_param = ANY(owned_powers) INTO has_power
  FROM user_powers 
  WHERE user_id = user_id_param;
  
  IF NOT has_power THEN
    RETURN FALSE;
  END IF;
  
  -- Determinar coluna do slot
  CASE slot_param
    WHEN 1 THEN slot_column := 'equipped_power_1';
    WHEN 2 THEN slot_column := 'equipped_power_2';
    WHEN 3 THEN slot_column := 'equipped_power_3';
    ELSE RETURN FALSE;
  END CASE;
  
  -- Atualizar o slot
  EXECUTE format('UPDATE user_powers SET %I = $1, updated_at = NOW() WHERE user_id = $2', slot_column)
  USING power_id_param, user_id_param;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Função para remover poder do slot
CREATE OR REPLACE FUNCTION unequip_power(user_id_param UUID, slot_param INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
  slot_column TEXT;
BEGIN
  -- Determinar coluna do slot
  CASE slot_param
    WHEN 1 THEN slot_column := 'equipped_power_1';
    WHEN 2 THEN slot_column := 'equipped_power_2';
    WHEN 3 THEN slot_column := 'equipped_power_3';
    ELSE RETURN FALSE;
  END CASE;
  
  -- Remover do slot
  EXECUTE format('UPDATE user_powers SET %I = NULL, updated_at = NOW() WHERE user_id = $1', slot_column)
  USING user_id_param;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Políticas RLS
ALTER TABLE user_powers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own powers" ON user_powers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own powers" ON user_powers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own powers" ON user_powers FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own powers" ON user_powers FOR DELETE USING (auth.uid() = user_id);

-- Criar registros iniciais para usuários existentes (se necessário)
INSERT INTO user_powers (user_id, owned_powers)
SELECT id, '{}'::integer[]
FROM auth.users
WHERE id NOT IN (SELECT user_id FROM user_powers);