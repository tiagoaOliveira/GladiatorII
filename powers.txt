CREATE TABLE powers (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  activation_chance INTEGER NOT NULL,
  icon VARCHAR(10) DEFAULT '‚ö°',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Inserir os poderes
INSERT INTO powers (name, description, activation_chance, icon) VALUES
('Faca R√°pida', 'Golpeia duas vezes rapidamente com 60% do dano base.', 20, '‚ö°'),
('Ataque Perfuro-Cortante', 'Ignora defesa do inimigo.', 15, 'üó°Ô∏è'),
('Frenesi', 'Duplica velocidade de ataque por 3 segundos.', 15, 'üí®'),
('F√∫ria', 'Garante +30% de chance de cr√≠tico nos pr√≥ximos 2 ataques. Perde 10% do HP m√°ximo ao ativar.', 25, 'üî•'),
('Berserker', 'Sempre que o HP estiver abaixo de 30%, o dano aumenta +20%.', 100, 'üò§'),
('Reflex√£o Total', 'Devolve 100% do dano recebido ao atacante.', 10, 'üõ°Ô∏è'),
('Guardi√£o Imortal', 'Ao receber um golpe fatal, resiste com 1 de HP. S√≥ pode ativar uma vez por combate.', 100, 'üíÄ');

-- Pol√≠ticas RLS
ALTER TABLE powers ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_powers ENABLE ROW LEVEL SECURITY;

-- Todos podem ver os poderes
CREATE POLICY "Anyone can view powers" ON powers FOR SELECT USING (true);

-- Usu√°rios podem ver apenas seus pr√≥prios poderes
CREATE POLICY "Users can view own powers" ON user_powers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own powers" ON user_powers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own powers" ON user_powers FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own powers" ON user_powers FOR DELETE USING (auth.uid() = user_id);

================================

DROP TABLE IF EXISTS user_powers;

CREATE TABLE user_powers (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  -- Poderes possu√≠dos (array de IDs)
  owned_powers INTEGER[] DEFAULT '{}',
  -- Poderes equipados nos slots
  equipped_power_1 INTEGER REFERENCES powers(id),
  equipped_power_2 INTEGER REFERENCES powers(id),
  equipped_power_3 INTEGER REFERENCES powers(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Fun√ß√£o para adicionar um poder ao usu√°rio
CREATE OR REPLACE FUNCTION add_power_to_user(user_id_param UUID, power_id_param INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
  user_exists BOOLEAN;
BEGIN
  -- Verificar se o usu√°rio j√° tem registro
  SELECT EXISTS(SELECT 1 FROM user_powers WHERE user_id = user_id_param) INTO user_exists;
  
  IF NOT user_exists THEN
    -- Criar registro do usu√°rio
    INSERT INTO user_powers (user_id, owned_powers) 
    VALUES (user_id_param, ARRAY[power_id_param]);
  ELSE
    -- Adicionar poder ao array se n√£o existir
    UPDATE user_powers 
    SET owned_powers = array_append(owned_powers, power_id_param),
        updated_at = NOW()
    WHERE user_id = user_id_param 
    AND NOT (power_id_param = ANY(owned_powers));
  END IF;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Criar registros iniciais para usu√°rios existentes (se necess√°rio)
INSERT INTO user_powers (user_id, owned_powers)
SELECT id, '{}'::integer[]
FROM auth.users
WHERE id NOT IN (SELECT user_id FROM user_powers);